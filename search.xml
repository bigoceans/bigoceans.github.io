<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PICNIC-V.2.0.0_一款给天空加滤镜的APP</title>
    <url>/2020/03/23/2.PICNIC-V.2.0.0_%E4%B8%80%E6%AC%BE%E7%BB%99%E5%A4%A9%E7%A9%BA%E5%8A%A0%E6%BB%A4%E9%95%9C%E7%9A%84APP/</url>
    <content><![CDATA[<p>虽然我是一个不拍照片的直男，但当我第一次透过picnic看我头顶的天空时，我就决定把它留在我的手机里！（大概也有近两年时间了）</p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<blockquote>
<h2 id="由于该博客最近搭建，所以只好将我其他平台的作品搬运过来，一些图片上有版权水印也请见谅哈"><a href="#由于该博客最近搭建，所以只好将我其他平台的作品搬运过来，一些图片上有版权水印也请见谅哈" class="headerlink" title="由于该博客最近搭建，所以只好将我其他平台的作品搬运过来，一些图片上有版权水印也请见谅哈"></a>由于该博客最近搭建，所以只好将我其他平台的作品搬运过来，一些图片上有版权水印也请见谅哈</h2></blockquote>
<h3 id="软件介绍："><a href="#软件介绍：" class="headerlink" title="软件介绍："></a><strong>软件介绍：</strong></h3><p><strong>PICNIC：是一款给天空加上各色滤镜的APP</strong><br><strong>优点：给天空加绝美的滤镜！无广告！打开即用！</strong><br><strong>版本号：v.2.0.0</strong><br><strong>测试机版本号：安卓8.0</strong><br><strong>效果：（不会拍照，这是随手一拍。。。不过按我技术随手和正经拍都一个样）</strong></p>
<p><img src="https://attach.52pojie.cn/forum/202003/01/233623t428df0qyb82dw22.png" alt="效果图1"></p>
<p><img src="https://attach.52pojie.cn/forum/202003/01/233626d74fqwcvnpiffonw.png" alt="效果图2"></p>
<p><strong><center>（左1为原图，另外三个仅仅做测试，不代表picnic的天空滤镜数量）</center>&gt;</strong></p>
<p><strong>软件运行图：</strong><br><strong>无广告加载界面，直接进入主界面。</strong><br><strong>无复杂功能碍眼，设置、相册、拍照已足矣。</strong></p>
<p><img src="https://attach.52pojie.cn/forum/202003/01/233628vix4vo8v2dioxdny.png" alt="效果图3"></p>
<p><strong>主功能很简单（效果真的很好！）就不一一介绍了，一键傻瓜式操作就能拍的漂漂亮亮的天空！</strong><br><strong>下面进入设置界面！</strong><br><strong>我们可以选择是否保留软件的水印、静音拍照、保留位置、取消软件消息通知（但我从来没印象收到过picnic的软件通知。。）</strong></p>
<p><img src="https://attach.52pojie.cn/forum/202003/01/233630v0pxlcx6cwcvmimx.png" alt="效果图4"></p>
<p><strong>总之，我是极力推这样的良心软件！</strong></p>
<p><strong>觉得有意思的朋友快快下载吧~</strong></p>
<p><strong>下载链接：</strong><br><strong>蓝奏云：</strong><a href="https://www.lanzous.com/i9txiih" target="_blank" rel="noopener">https://www.lanzous.com/i9txiih</a></p>
<p><strong>百毒云：</strong><br><strong>链接：</strong> <a href="https://pan.baidu.com/s/1u9saCy-0xq1Vv6xUAQMTTA" target="_blank" rel="noopener">https://pan.baidu.com/s/1u9saCy-0xq1Vv6xUAQMTTA</a> <strong>提取码：<code>kgly</code></strong><br><strong>蓝奏云二维码下载：</strong></p>
<p><img src="https://attach.52pojie.cn/forum/202003/01/233621x6jpr216i6mnpi0j.png" alt="二维码下载"></p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>安卓</category>
      </categories>
  </entry>
  <entry>
    <title>model</title>
    <url>/2020/03/23/model/</url>
    <content><![CDATA[<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
  </entry>
  <entry>
    <title>重装系统&amp;激活系统</title>
    <url>/2020/03/21/1.%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F&amp;%E6%BF%80%E6%B4%BB%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>对于刚刚DIY好一台电脑或者对于目前所用windows系统版本不太满意的人来说，下载一个官方、纯净的系统镜像是至关重要的！下面就来看看如何实现这些操作吧。（所有操作均以Win10为例）</p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<h3 id="首先说说为什么官方的系统受人推崇吧"><a href="#首先说说为什么官方的系统受人推崇吧" class="headerlink" title="首先说说为什么官方的系统受人推崇吧:"></a>首先说说为什么官方的系统受人推崇吧:</h3><p><strong>首先说说第三方系统镜像：</strong></p>
<blockquote>
<p>第一：由第三方人员在官方的系统的基础上修改而得，由于其中集成了大量工具和软件，较为简单易用，所以流传广泛。但是这<strong>并不能</strong>排除其中包含木马和病毒的可能。最重要的就是其中集成的软件九成都是流氓软件，例如臭名昭著的2345、各种页游等等等(得罪不起不一一点名)。为什么要把这些流氓软件集成到第三方系统去呢？当然是牟利哈，百度一下<strong>2345装机联盟</strong>即可知晓。</p>
<p>第二：在第三方系统制作人员打包封装系统的时候会把一些驱动或者激活信息封装进去，要知道驱动是和硬件相关联的，每个人的硬件不可能一模一样，即便是“万能驱动”在使用第三方系统的时候也免不了会有因<strong>驱动不匹配或激活信息故障导致蓝屏甚至装机失败。</strong></p>
</blockquote>
<p><strong>再来说说官方的系统镜像</strong></p>
<blockquote>
<p><strong>完全没毛病！</strong>各种更新版本和系统类别全部由用户自己选择，系统不会有任何第三方流氓软件。</p>
</blockquote>
<h3 id="那么该如何获取官方系统镜像呢？"><a href="#那么该如何获取官方系统镜像呢？" class="headerlink" title="那么该如何获取官方系统镜像呢？"></a>那么该如何获取官方系统镜像呢？</h3><p><strong>毫无疑问，微软官方下载就是渠道之一</strong></p>
<blockquote>
<p><a href="https://www.microsoft.com/zh-cn/software-download/" target="_blank" rel="noopener">微软官方下载</a></p>
<p>在微软官方下载会使用MeidaCreationTool下载工具（类似于N卡的GeForceExperience）可以本机升级系统，下载iso镜像到本地、或者下载iso镜像并写入U盘，缺点就是下载速度慢。</p>
</blockquote>
<p><strong>还有个下载官方系统的好去处</strong></p>
<blockquote>
<p><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN,我告诉你</a></p>
<p>MSDN,我告诉你：全部采用ed2k开头的链接进行下载，包含SHA1校验信息。而且ed2k下载链接可以使用迅雷、百度网盘等工具进行下载，如果条件允许，下载速度较官方的MCT下载工具相比有显著提升。另外和微软官网的相比，这里的收录相对更全，也更方便查找下载不同的版本。</p>
<center>冗长的系统选择页面</center>
![冗长的系统选择页面](https://i.loli.net/2020/03/21/DCZoOUcTlq6RQBX.gif)
</blockquote>
<p><strong>写给对系统安全格外重视的朋友</strong></p>
<blockquote>
<p>你们的担心不无道理，若是连镜像都是残缺或者携带捆绑甚至是病毒，那么装机过程再怎么完美也都是瞎费工夫。所以，大家可以下载一个Hash_MD5的校验工具，将下载的系统镜像拖拽进校验工具的工作窗口对比是否和网站提供的SHA1值一致，不一致则重新下载该镜像。</p>
<p><a href="https://www.lanzous.com/iahx8gj" target="_blank" rel="noopener">Hash_MD5校验工具</a><strong>密码:</strong><code>ocean</code></p>
</blockquote>
<h3 id="下载好系统镜像之后呢？"><a href="#下载好系统镜像之后呢？" class="headerlink" title="下载好系统镜像之后呢？"></a>下载好系统镜像之后呢？</h3><p><strong>需要一个做好”格式化”准备的U盘</strong></p>
<blockquote>
<p>你需要准备一个≥16GB的U盘（8GB也可以，但这年头8GB的U盘实属罕见）</p>
</blockquote>
<p><strong>下载软碟通</strong></p>
<blockquote>
<p><a href="https://www.lanzous.com/iahxp9e" target="_blank" rel="noopener">软碟通单文件免安装版本</a><strong>密码:</strong><code>ocean</code></p>
</blockquote>
<p><strong>用下载好的镜像通过软碟通制作一个U盘装机盘</strong></p>
<blockquote>
<p>1、右键”以管理员身份运行”软碟通</p>
<p>2、打开UltraISO的窗口后依次点击左上角的“文件”-“打开”-找到存放镜像文件的目录</p>
<p>3、选中该目标文件，点击“打开”按钮</p>
<p>4、插入准备好的U盘</p>
<p>5、再次回到UltraISO窗口，点击菜单栏中的“启动”选“写入硬盘镜像”</p>
<p>6、接下来在弹出的窗口直接点击“写入”按钮<strong>(注：将写入方法选择为“USB-HDD+”，如果不是这个模式，可能导致电脑无法通过U盘正常启动。)</strong></p>
<p>7、静候片刻，软碟通正在将系统的镜像文件数据写入到U盘里</p>
<p>8、下载<a href="https://www.lanzous.com/iahz5vi" target="_blank" rel="noopener">HWID数字权利激活程序</a><strong>密码:</strong><code>ocean</code>将文件下载到你的U盘里(放在根目录就好，激活系统的时候会比较好找)</p>
<p>9、做好一切准备后就开始重装系统吧</p>
</blockquote>
<h3 id="开始重装系统-以Win10为例"><a href="#开始重装系统-以Win10为例" class="headerlink" title="开始重装系统(以Win10为例)"></a>开始重装系统(以Win10为例)</h3><p><strong>首先你需要知道你的电脑进入”选择启动项选择”页面的快捷键是什么,或者是进入BIOS系统的快捷键是什么</strong></p>
<blockquote>
<center>其他品牌也可以试试比较大众的启动项选择快捷键</center>
![各品牌台式机主板笔记本启动项](https://i.loli.net/2020/03/21/IU4vSlsDKrhjBzy.png)
</blockquote>
<p><strong>插入U盘，在按下电源键的瞬间请用最快手速狂戳对应电脑/主板的快捷键，比如大众一点的按键<code>F12/Delete</code></strong></p>
<blockquote>
<p>按下后请选择你插入的U盘的名字，比如是金士顿的64GBU盘那么它的名字就类似Kingston-flashdisk-64GB</p>
<p>或者是其他检测不到品牌的U盘，你可以找FlashDisk、储存量等闪存的关键字样</p>
</blockquote>
<p><strong>因为我们是直接用软碟通将镜像写入了U盘，所以不同于一些进PE系统装机的教程</strong></p>
<blockquote>
<p>不同于PE装机，我们则会直接进入到经典的Windows系统安装界面：</p>
<p>1、选择语言后点击下一步-选择要安装的系统版本（如果你下载的是整合版、就是多个版本和在一起的镜像，那么就会出现这个页面供你选择），例如win10会有教育版、企业版、专业版三种供你选择，默认选专业版。</p>
<p>2、安装类型选择”自定义：仅安装Windows(高级)(C)”后自动进入”你想将windows安装在哪里？”页面</p>
<p>3、选中类型名为”主分区”的驱动器，你可以选择先将其格式化，再点击下一步。也可选中后直接下一步，效果应该是大差不差的</p>
<p>4、等待系统安装</p>
<p>5、成功进入系统，开始个性设置。</p>
</blockquote>
<h3 id="系统激活-以Win10为例"><a href="#系统激活-以Win10为例" class="headerlink" title="系统激活(以Win10为例)"></a>系统激活(以Win10为例)</h3><p><strong>开心的进入系统并开始进行个性设置时突然发现，这个系统还没有激活，该怎么办？</strong></p>
<blockquote>
<p>在此之前，我先介绍一下早在制作好U盘启动盘时让你们下载的<a href="https://www.lanzous.com/iahz5vi" target="_blank" rel="noopener">HWID数字权利激活程序</a><strong>密码:</strong><code>ocean</code>吧</p>
<p><strong>以前：</strong>在还没有出现数字权利工具的时候，某知名网站（软慧网）上有大神写过一个Windows10专业版数字权利获取方法，即使现在教程用途不太大，不过有兴趣的可以去看一下。传送门：<a href="https://www.ruanhuicn.com/key/" target="_blank" rel="noopener">https://www.ruanhuicn.com/key/</a></p>
<p><strong>如今：</strong>到后来国外某知名论坛传出win10数字权利工具–HWIDGEN</p>
<center>win10数字权利工具--HWIDGEN</center>
![win10数字权利工具--HWIDGEN](https://i.loli.net/2020/03/21/61ejxSHT9IMGvyF.png)

<p>在HWID出现之后，数字权利激活Windows10并不是难事了，只需要进行简单的点击操作就可以得到一个数字权利激活成功的Windows系统。</p>
<p><strong>科普：</strong>数字权利，是针对Windows10系统而言的一种激活方式。全称“使用数字许可证激活” 使用数字权利激活和普通激活方式有什么区别呢？十分重要的一点就是数字权利激活后支持重装，即在重装系统之后可以自动激活系统，保持正版！当然前提条件就是重装系统的时候需要保持和获取数字权利的系统版本保持一致并且需要确保没有更换硬件！<strong>可以简单的认为数字权利激活是永久激活！</strong>区别于kms激活，数字权利是永久的，无需90天循环和kms服务器，风险系数更小。</p>
<p><strong>HWID支持的版本：</strong>除Windows10 LTSC 2019 和Windows10 server系列系统外，换句话说：适用于大多数Windows10系统，例如win10家庭版、专业版、ltsb2016等等……</p>
</blockquote>
<p><strong>win10数字权利工具–HWIDGEN的使用方法</strong></p>
<blockquote>
<blockquote>
<ul>
<li><strong>确保电脑能正常联网</strong>，网络正常稳定以确保能够成功连接微软服务器</li>
<li>尽量<strong>关闭360、电脑管家之类的杀毒软件</strong>，防止软件被吞无法使用</li>
<li>确保<strong>Windows update服务已开启(这一项无需关心，系统默认都是开启update服务的)未被禁用</strong>，禁用过的请开启后使用。激活成功后可关闭。</li>
<li>打开软件，在工作模式选择HWID，然后点击开始即可</li>
<li>只能用于Windows10系统，其他系统无效。</li>
<li>Windows10 LTSC 2019 和 Server版本可以在工作模式切换KMS38进行激活</li>
</ul>
</blockquote>
</blockquote>
<p><strong>总结一下使用HWID激活的步骤：</strong>先把HWID从你的U盘里拉倒桌面，然后按照上述方法操作激活，成功后就可以把HWID删掉了。</p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>微软</category>
      </categories>
  </entry>
  <entry>
    <title>C语言编写贪吃蛇游戏</title>
    <url>/2020/03/21/7.C%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><strong>你问我为什么要用c写贪吃蛇游戏？一切都要从那次作业讲起。。。</strong></p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><blockquote>
<p>大一上半年，C程序设计老师布置了一个程序设计作业，于是诞生了这篇代码。</p>
</blockquote>
<h3 id="IDE："><a href="#IDE：" class="headerlink" title="IDE："></a>IDE：</h3><blockquote>
<p>VisualStudio2017社区版</p>
</blockquote>
<h3 id="字符集："><a href="#字符集：" class="headerlink" title="字符集："></a>字符集：</h3><blockquote>
<p>使用多字节字符集</p>
</blockquote>
<h3 id="辅助工具："><a href="#辅助工具：" class="headerlink" title="辅助工具："></a>辅助工具：</h3><blockquote>
<p>EasyX图形库2018春分版</p>
</blockquote>
<h3 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h3><p>   <strong>1、因为当时想得高分就以为搞点花里胡哨的就不错（哈哈最后混了个优，乐死我了），所以我编写了账号注册、登录系统、调用了多媒体接口以登录游戏时播放背景音乐、高分榜系统以及附带的升序降序排行函数：</strong></p>
<p>​            ①账号注册、登录系统、高分榜系统的数据全部分别保存在默认添加创建的Users.dat,scores.dat里，所以要借鉴的朋友需要手动在IDE里添加这两个文件（对应名称可以自己改，但一定要对应到代码里，否则会fp指针调用文件出错）；</p>
<p>​          ②关于背景音乐：我添加的背景音乐的资源就不放到帖子上了（名字叫silver city，好听，哈哈哈），所以要借鉴源码的朋友需要自己了解一下“如何添加MP3格式的音乐到代码”的问题，然后对代码第328行进行改写;</p>
<p>​    <strong>2、操作问题：因为我喜欢玩FPS游戏，所以定义的上下左右是wsad（小写，一定要把输入法切换为小写英文状态，否则蛇死亡），所以不习惯的朋友可以重新定义为键盘方向键（需要了解一下键盘虚拟键值，然后改对应的switch语句，代码量应该还是挺大的）。</strong></p>
<p>​    <strong>3、EasyX图形库：（这段是复制我设计报告的23333333）在我决定用EasyX库的图形函数来绘制地图之前，对于这个模块的编写有很多问题：譬如单用gotoxy()函数实现绘制地图的话，一片黑白，惨不忍睹；而且也会成几何倍的增加代码量：尤其是for循环语句和printf语句会多不胜数。从而就会导致不仅开发人员降低对于代码的可读性，而且从头至尾的黑白界面无疑会劝退很多玩家，降低可玩性。在我用EasyX来绘制地图后，测试的过程只能用两个字来形容：真香！EasyX的一个moveto()配合一个for循环代替了多不胜数的gotoxy()函数和for循环。这不仅大大缩减了代码量，而且图形编程的优点“多彩化”也得以体现。在调试过程中我对for循环进行了优化：一个进行边界的上下绘制，另一个负责左右的绘制，实现了不仅减少了代码量而且没有破坏不影响可读性的前提。</strong></p>
<p>​    <strong>4、应程序设计老师要求，基本上能达到每个功能、每个函数甚至每一句都有一条注释。。。（想想都要吐了）</strong></p>
<hr>
<p><strong>放代码吧：</strong></p>
<pre class=" language-c++"><code class="language-c++">#include <stdio.h>                        //C语言标准输入输出头文件
#include <graphics.h>                // easyx图形库头文件
#include <conio.h>                        //获取数据头文件（getch()和kbhit()）
#include <windows.h>                //使用其中的Sleep函数控制循环的时间，system("cls")函数来清屏
#include <stdlib.h>                        //调用了srand()随机函数
#include <time.h>                        //使用当前时钟做随机种子
#include <mmsystem.h>                //多媒体设备接口头文件
#pragma comment (lib,"winmm.lib")

//首先进行一堆宏定义

//定义地图大小
#define frame_height 30 
#define frame_width 30
//定义操作键，小写的wasd控制上左下右
#define UP 'w' 
#define DOWN 's'
#define LEFT 'a'
#define RIGHT 'd'
//控制台的点是单位点，不考虑大小，我们用的easyx绘制像素点为了将单位点在图形界面上放大为一个正方形，系数转换×16可以把一个单位点放大成正方形。16可以是任意数，相应的会放大或缩小所有的像素点。
#define SIZE 16

#define N 4

//声明fp是指针，用来指向FILE类型的对象。
FILE *fp;

int i, j, k, m, n, s[N];

char s1[4], s2[4];
//蛇的初始方向
char ch = UP;
//定义一个全局变量，来判断蛇是否成长，成长则速度加快。grow值也相应增加。
int grow = 0;



//食物的坐标
struct Food {
        int x;
        int y;
}food;

//蛇的信息：snake[0]是蛇头，len为蛇的长度，speed蛇的速度
struct Snake {
        int x[50];
        int y[50];
        int len;
        int speed;
}snake;

//用于储存用户账号密码
typedef struct The_users
{
        char id[11]; //账号
        char pwd[20];//密码
}users;
users a, b;//新建结构体成员变量,用来登陆与注册


//此处声明变量

void init_map(void);
void update_food(void);
void move_snake(void);
int is_alive(void);
void get_speed(void);
void gotoxy(int x, int y);
void redraw_map(void);
void menu();
void registers();
void Login();
//void Create_File();
void score();
int compInc(const void *a, const void *b);
int compDec(const void *a, const void *b);


//主函数位置
int main()
{
        initgraph(640, 480);        //创建绘图窗口，长640.
        menu();                                        //调用菜单函数
        score();                                //调用得分函数
        return 0;
}


//再次绘制地图（根据宏定义中的宽和高）
void redraw_map(void)
{
        for (j = 0; j < frame_width; j++)                        //该for循环用于绘制地图的上下边界，根据width宽来从左往右、先上后下依次绘制。
        {
                moveto(j*SIZE, 0);                                                //将画笔移动到(j*SIZE,0)的位置开始进行下面的绘图，另外(j*SIZE)是将单位点放大SIZE（16）倍
                setfillcolor(BLUE);                                                //定义上边界为蓝色
                fillrectangle(j*SIZE, 0, j*SIZE + SIZE, SIZE);        //绘制矩形
                moveto(j*SIZE, (frame_height - 1)*SIZE);//再次移动画笔
                setfillcolor(BLUE);                                                //定义下边界为蓝色
                fillrectangle(j*SIZE, (frame_height - 1)*SIZE, j*SIZE + SIZE, (frame_height - 1)*SIZE + SIZE);//绘制矩形
        }
        for (i = 1; i < frame_height - 1; i++)//次循环绘制地图左右剩余的28个矩形方块,先左后右，从上至下！
        {
                moveto(0, i*SIZE);                                //画笔移动到(0,i*SIZE)
                setfillcolor(BLUE);                                //定义左边界为蓝色
                fillrectangle(0, i*SIZE, 0 + SIZE, i*SIZE + SIZE);
                moveto((frame_width - 1)*SIZE, i*SIZE);//再次移动画笔
                setfillcolor(BLUE);                                        //定义右边界为蓝色
                fillrectangle((frame_width - 1)*SIZE, i*SIZE, (frame_width - 1)*SIZE + SIZE, i*SIZE + SIZE); //绘制矩形
        }
}

//然后初始化地图内容
void init_map(void)
{
        //初始化食物
        srand((unsigned int)time(NULL));//用srand函数集结合time.h头文件中的time来生成随机数
        food.x = rand() % (frame_height - 2) + 1;//在1~（frameheight-2）之间随机生成一个食物的横坐标
        food.y = rand() % (frame_width - 2) + 1;//在1~（framewidth -2）之间随机生成一个食物的纵坐标
        moveto(food.y*SIZE, food.x*SIZE);                //将画笔移动到该随机坐标
        setfillcolor(RED);                                                //定义食物为红色
        fillcircle(food.y *SIZE + SIZE / 2, food.x*SIZE + SIZE / 2, SIZE / 2);                //定义食物形状为以(food.y *SIZE + SIZE / 2, food.x*SIZE + SIZE / 2)为圆心，SIZE/2为半径的圆形

        //初始化蛇
        snake.x[0] = (frame_height) / 2;//初始化蛇头横坐标位置
        snake.y[0] = (frame_width) / 2;//初始化蛇头纵坐标位置
        moveto(snake.y[0] * SIZE, snake.x[0] * SIZE);//画笔移动到蛇头坐标
        setfillcolor(GREEN);                        //定义蛇的初始颜色为绿色
        fillcircle(snake.y[0] * SIZE + SIZE / 2, snake.x[0] * SIZE + SIZE / 2, SIZE / 2);//画蛇
        snake.len = 3;                                                //初始化蛇的节数为3节
        snake.speed = 200;                                        //初始化蛇的速度
        for (k = 1; k < snake.len; k++)                //用for循环画出蛇剩余的节数
        {
                snake.x[k] = snake.x[k - 1] + 1;
                snake.y[k] = snake.y[k - 1];
                moveto(snake.y[k] * SIZE, snake.x[k] * SIZE);
                setfillcolor(GREEN);
                fillcircle(snake.y[k] * SIZE + SIZE / 2, snake.x[k] * SIZE + SIZE / 2, SIZE / 2);
        }
}

//生成食物
void update_food()
{
        if (snake.x[0] == food.x&&snake.y[0] == food.y)//首先保证每次随机的食物不能刚好随机到蛇头所在坐标
        {
                food.x = rand() % (frame_height - 2) + 1;
                food.y = rand() % (frame_width - 2) + 1;
                for (k = 1; k < snake.len; k++)
                {
                        if (snake.x[k] == food.x&&snake.y[k] == food.y)//判断蛇头坐标等于随机食物的坐标 即：吃到食物
                        {
                                food.x = rand() % (frame_height - 2) + 1;//再次随机生成食物
                                food.y = rand() % (frame_width - 2) + 1;
                        }
                }
                moveto(food.y*SIZE, food.x*SIZE);//移动画笔到随机食物的坐标
                setfillcolor(RED);                                //定义食物颜色为红色
                fillcircle(food.y*SIZE + SIZE / 2, food.x*SIZE + SIZE / 2, SIZE / 2);                //定义食物为圆形
                snake.len++;                                        //蛇的长度加一
                grow = 1;                                                //给全局变量grow赋值1
        }
}

//蛇的移动
void move_snake()
{
        if (_kbhit())//kbhit判断键盘输入的虚拟键值
                ch = _getch();//将方向键值表现为对应的方向
        if (!grow)//此时grow值若为零则执行if语句，不为零则不执行
        {
                moveto(snake.y[snake.len - 1] * SIZE, snake.x[snake.len - 1] * SIZE);
                setfillcolor(BLACK);
                solidrectangle(snake.y[snake.len - 1] * SIZE, snake.x[snake.len - 1] * SIZE, snake.y[snake.len - 1] * SIZE + SIZE, snake.x[snake.len - 1] * SIZE + SIZE);
        }
        for (k = snake.len - 1; k > 0; k--)
        {
                snake.x[k] = snake.x[k - 1];
                snake.y[k] = snake.y[k - 1];
        }
        switch (ch)
        {
        case UP:  snake.x[0]--; break;
        case DOWN: snake.x[0]++; break;
        case LEFT:  snake.y[0]--; break;
        case RIGHT:  snake.y[0]++; break;
        default:  break;                                        //其他按键直接导致死亡
        }
        moveto(snake.y[0] * SIZE, snake.x[0] * SIZE);
        setfillcolor(GREEN);
        fillcircle(snake.y[0] * SIZE + SIZE / 2, snake.x[0] * SIZE + SIZE / 2, SIZE / 2);
        grow = 0;
}

//判断是否存活
int is_alive(void)
{
        if (snake.x[0] == 0 || snake.x[0] == frame_height - 1 || snake.y[0] == frame_width - 1 || snake.y[0] == 0)//判断是否撞墙
                return 0;                //死
        for (k = 1; k < snake.len; k++)
                if (snake.x[k] == snake.x[0] && snake.y[k] == snake.y[0])//判断蛇头是否撞到蛇的身体
                        return 0;        //死
        return 1;                        //活
}

//通过节数来提升速度
void get_speed(void)
{
        if (snake.len <= 6)
                snake.speed = 200;
        else if (snake.len <= 10)
                snake.speed = 100;
        else if (snake.len <= 20)
                snake.speed = 50;
        else if (snake.len <= 30)
                snake.speed = 30;
        else snake.speed = 20;
}

//移动光标
void gotoxy(int x, int y)
{
        HANDLE hout;
        COORD cor;
        hout = GetStdHandle(STD_OUTPUT_HANDLE);
        cor.X = y;
        cor.Y = x;
        SetConsoleCursorPosition(hout, cor);
}

//进入界面
void menu()
{
        InputBox(s1, 4, "输入数字以选择目的：\n1.开始游戏\n2.高分榜\n3.退出游戏\n游戏说明：wasd控制上左下右(小写)", "疯狂的蛇——海制作", NULL, 0, 0, false);
        int x, y[3];
        sscanf_s(s1, "%d", &x);//将用户输入转化为数字
        if (x == 1)
        {
                InputBox(s2, 4, "输入数字以选择目的：\n1.注册账号\n2.登陆游戏", "疯狂的蛇——海制作");
                sscanf_s(s2, "%d", &x);
                if (x == 1) {
                        registers();
                        Login();
                }
                else if (x == 2) {
                        Login();
                }
                init_map(); //初始化地图
                while (1)
                {
                        update_food();
                        get_speed();
                        move_snake();
                        redraw_map();
                        Sleep(snake.speed);
                        if (!(is_alive()))
                                break;
                }
                closegraph();                                                //关闭游戏窗口
                printf("哈哈小辣鸡，游戏结束!\n");
                printf("你的得分：%d", snake.len - 3);//得分=(蛇死亡前节数len)-(蛇的初始节数3)
                _getch();
        }
        else if (x == 2)
        {
                closegraph();                                                //关闭游戏窗口
                printf("                    排行榜\n");
                fopen_s(&fp, "scores.dat", "r");
                for (x = 0; x < N - 1; x++) {
                        fscanf_s(fp, "%d", &y[x]);
                        printf("%d\n", y[x]);
                }
                fclose(fp);
                _getch();

        }
        else//输入3或其他除了1、2任意键均退出游戏
        {
                closegraph();
        }
}

//注册系统
void registers()
{
        fopen_s(&fp, "Users.dat", "r");
        fscanf_s(fp, "%s%s", b.id, sizeof(b.id), b.pwd, sizeof(b.pwd));
        InputBox(a.id, 11, "请输入你的账号：", "疯狂的蛇——海制作");
        while (1)
        {
                if (strcmp(a.id, b.id) != 0)//如果两串字符串不相等
                {
                        if (!feof(fp))//如果未至文件末尾,它的工作原理是，站在光标所在位置，向后看看还有没有字符。如果有，返回0；如果没有，返回非0。它并不会读取相关信息，只是查看光标后是否还有内容。
                        {
                                fscanf_s(fp, "%s%s", b.id, sizeof(b.id), b.pwd, sizeof(b.pwd));
                        }
                        else break;
                }
                else
                {
                        outtextxy(220, 200, "此用户名已被注册");
                        fclose(fp);
                        _getch();
                        exit(0);
                }
        }
        fclose(fp);
        InputBox(a.pwd, 10, "请输入你的密码：", "疯狂的蛇——海制作");
        fopen_s(&fp, "Users.dat", "a");
        fprintf_s(fp, "%s %s\n", a.id, a.pwd);
        outtextxy(220, 200, "奥利给！恭喜你！账号注册成功！");
        fclose(fp);
}

//登陆账号密码，登录时播放bgm嘿嘿sao起来
void Login()
{
        mciSendString("open SC.mp3 alias BIGOcean", 0, 0, 0);
        mciSendString("play BIGOcean repeat", 0, 0, 0);
        fopen_s(&fp, "Users.dat", "r");
        fscanf_s(fp, "%s%s", b.id, sizeof(b.id), b.pwd, sizeof(b.pwd));
        InputBox(a.id, 11, "请输入账号", "疯狂的蛇——海制作");
        while (1)
        {
                if (strcmp(a.id, b.id) == 0) break;//如果找到了这个用户名
                else
                {
                        if (!feof(fp))//如果文件未读完
                                fscanf_s(fp, "%s%s", b.id, sizeof(b.id), b.pwd, sizeof(b.pwd));
                        else
                        {
                                outtextxy(220, 200, "此用户名不存在!");
                                fclose(fp);
                                _getch();
                                exit(0);
                        }
                }
        }
        InputBox(a.pwd, 20, "请输入密码", "疯狂的蛇——海制作");
        if (strcmp(a.pwd, b.pwd) == 0)//如果密码匹配
        {
                fclose(fp);
                outtextxy(250, 200, "登陆成功！奥利给！");
                initgraph(640, 480);
        }
        else
        {
                outtextxy(220, 200, "STFU!密码不正确");
                _getch();
                exit(0);
        }
}

//分数系统
void score()
{
        fopen_s(&fp, "scores.dat", "r");
        for (n = 0; n < N - 1; n++)
        {
                fscanf_s(fp, "%d", &m);
                s[n] = m;
        }
        s[N - 1] = snake.len - 3;
        qsort(s, N, sizeof(s[0]), compDec);
        fclose(fp);
        fopen_s(&fp, "scores.dat", "w");
        for (n = 0; n < N - 1; n++)
        {
                fprintf_s(fp, "%d\n", s[n]);
        }
        fclose(fp);
}

//分数的排序
//升序排序
int compInc(const void *a, const void *b)
{
        return *(int *)a - *(int *)b;
}
//降序排序
int compDec(const void *a, const void *b) {
        return *(int *)b - *(int *)a;
}</code></pre>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>语言类</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析量--时间复杂度</title>
    <url>/2020/03/21/8.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E9%87%8F-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<p>文章创造背景：我们知道时间复杂度是学习算法的基石，但还是有很多朋友对这个概念不很理解，那么我们就来聊聊它如何“刻画”出一个算法的运行损耗的时间量。</p>
<blockquote>
<h3 id="文章叙述方式："><a href="#文章叙述方式：" class="headerlink" title="文章叙述方式："></a>文章叙述方式：</h3><p>我会用一种对话方式尽可能让对于时间复杂度还不懂的朋友清晰明了的对它建立概念。</p>
<h3 id="文章对话人物："><a href="#文章对话人物：" class="headerlink" title="文章对话人物："></a>文章对话人物：</h3><p>秦老师、大海同学。</p>
<h3 id="文章内容分配："><a href="#文章内容分配：" class="headerlink" title="文章内容分配："></a>文章内容分配：</h3><p>我将内容分为三个部分：<br>                                                         一：如何刻画一个算法消耗的时间量？<br>                                                         二：时间复杂度的概念怎么得出来的？<br>                                                         三：如何去计算一个算法的时间复杂度？</p>
</blockquote>
<hr>
<p><strong><center> 一：如何刻画一个算法消耗的时间量？ </center></strong></p>
<p><img src="https://i.loli.net/2020/03/20/ZjDApaJdohRSW7s.png" alt="对话1"><br><img src="https://i.loli.net/2020/03/21/bL4zArIgvcMV6WE.png" alt="对话2"></p>
<blockquote>
<center>为了方便朋友们看清楚，我把截图单独拉出来</center>
</blockquote>
<p><img src="https://i.loli.net/2020/03/21/SiL27DqdI8Mlkew.png" alt="插图1"><br><img src="https://i.loli.net/2020/03/21/wFdNMvce9ACgW1m.png" alt="对话3"><br><strong><center> 二：时间复杂度的概念怎么得出来的？ </center></strong><br><img src="https://i.loli.net/2020/03/21/ybt1zsgxEGTVYD5.png" alt="对话4"></p>
<blockquote>
<center>为了方便朋友们看清楚，我把截图单独拉出来</center>
</blockquote>
<p><img src="https://i.loli.net/2020/03/21/5sMtQi9VerGRU3S.png" alt="插图2"><br><img src="https://i.loli.net/2020/03/21/9T1OpMCjs3SRuVw.png" alt="对话5"><br><strong><center> 三：如何去计算一个算法的时间复杂度？ </center></strong><br><img src="https://i.loli.net/2020/03/21/1V6ZdEpfRncJx8t.png" alt="对话6"><br><img src="https://i.loli.net/2020/03/21/xdCXKkOosrH24b3.png" alt="对话7"></p>
<blockquote>
<center>为了方便朋友们看清楚，我把截图单独拉出来</center>
</blockquote>
<p><img src="https://i.loli.net/2020/03/21/Tb8zhHRcWgQ5e1n.png" alt="插图3"><br><img src="https://i.loli.net/2020/03/21/64o3aY5zK29OQTd.png" alt="对话8"><br><img src="https://i.loli.net/2020/03/21/vpNVqFJo9Un2DP1.png" alt="对话9"></p>
<hr>
<p><strong>至此呢，关于我对时间复杂度理解的文章已暂时完结！<br>感谢秦老师和大海同学助力！</strong></p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法类</tag>
        <tag>语言类</tag>
      </tags>
  </entry>
  <entry>
    <title>一起来看看火爆的手机号码一键登录</title>
    <url>/2020/03/03/9.%E4%B8%80%E8%B5%B7%E6%9D%A5%E7%9C%8B%E7%9C%8B%E7%81%AB%E7%88%86%E7%9A%84%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E4%B8%80%E9%94%AE%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>不知你是否发现：大批手机 <code>app</code> 登录页面，突然之间变成了一键登录。之前大火的 <code>通过手机号码获取短信验证码</code> 登录模式正悄悄退去。这神奇的操作是如何实现的呢？</p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>之前所有的登录页面千篇一律为「手机号」「验证码」（暂且忽略账号密码以及第三方登录模式），这是因为想要验证「你就是你」，在手机号实名认证的时代，通过向号主本人发送验证码来验证登录是较为稳妥的方式，事实证明也的确如此。但是受网络延迟以及操作繁琐等影响，对于用户留存以及用户新增有着不小的挑战。</p>
<p>也许你会想 <code>APP</code> 直接读取手机号验证号主身份不就好了嘛？对不起，如果哪家公司公开窃取手机号，离监狱就是负距离。这时三家通讯公司瞄准了这一市场，开放了相关能力，即通过调用运营商的接口，判断用户输入的手机号与本机号码是否一致。但细细一想，用户还是需要填写手机号，如果运营商直接把手机号返回给我们，那该多棒啊！这么一来「一键登录」就诞生了。</p>
<blockquote>
<p>运营商是具备通过 <code>sim</code> 卡数据查询到手机号码的权限以及能力的。</p>
</blockquote>
<p>刚才说到三家运营商开放了相关接口，但是他们毕竟是竞争关系，彼此之间互不兼容，而且提供的优惠以及方式也是不同的。好比移动出了一款4G套餐100分钟500M；联通出了同价位套餐200分钟10G；电信一看不行，出了不限流量。作为用户的我们肯定会根据自身情况选择最合适的，但是一般也是只选其一。不要说你办了三家的卡，而且为了同时使用甚至买了三个手机，如果你是如此土豪，请收下我的膝盖。因此，对于我们应用，集成三家通讯商的 <code>SDK</code> 是不是有点不那么方便以及划算呢？第三方平台便应运而生，比如某蓝（因为他们公司至少有3个推广添加了我的微信，所以我印象颇深）。</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>作为技术人员，其实最关心的还是实现方式。结合网上各个平台的调用方式，绘制了此图：</p>
<p><img src="/images/%E6%89%8B%E6%9C%BA%E4%B8%80%E9%94%AE%E7%99%BB%E5%BD%95.png" alt="揭秘一键登录"></p>
<p>1) 用户打开 <code>app</code> 请求登录</p>
<p>2) 显示登录， <code>app</code> 通过内置的认证 <code>SDK</code> 向运营商获取手机号码</p>
<p>3) 获取成功时，为用户展示授权页面（就是是否一键登录）</p>
<p>4) 等待用户进行点击授权</p>
<p>5) 用户同意授权</p>
<p>6) <code>SKD</code> 得到授权之后，获取 <code>token</code> ，然后向 <code>app</code> 返回接口调用 <code>token</code></p>
<p>7) <code>app</code> 向 <code>app服务器</code> 传递获取到的 <code>token</code></p>
<p>8) <code>app服务器</code> 拿着客户端传过来的 <code>token</code> 请求 <code>认证服务器</code> 获取手机号码接口</p>
<p>9) <code>认证服务器</code> 返回手机号码给应用服务器</p>
<p>10) 登录成功</p>
<h2 id="3-后话"><a href="#3-后话" class="headerlink" title="3.后话"></a>3.后话</h2><p>虽然一键登录不仅比短信验证码收取的费用便宜相差不大，但是其节省的时间以及简化的操作无疑能增加新用户的注册体验。</p>
<p>对了，还有一点你需要知道，那就是这一操作必须建立在拥有顺畅的网络基础之上。</p>
<blockquote>
<p>三大运营商提供的接口操作对网络要求各不相同，但都<strong>&lt;不支持 <code>WiFi</code> 无线网络&gt;</strong>，最好是 <code>3G</code> +</p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>网络类</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之排序</title>
    <url>/2020/02/15/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>排序的归纳以及时间复杂度表</strong><br><img src="https://i.loli.net/2020/03/23/7KQYAkbX4RwBgml.png" alt="排序时间复杂度"></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>冒泡排序是一个比较简单的排序，它是一次比较相邻两个元素的值，如何顺序错误就交换两个数的位置，一直到没有交换的数为止，排序结束。</strong></p>
<p><strong>若对n个数进行排序，我们需要n-1次比较，所以第k次比较需要进行n-k次比较。</strong>&gt;</p>
<blockquote>
<p>排序算法通过以数据对象的两两比较作为关键所以可以得出，冒泡排序需要进行的比较次数为：(n-1) + (n-2) + … + 1 = n<em>(n-1) / 2。<br>因此冒泡排序的  *</em>时间复杂度为O(n^2)**</p>
</blockquote>
<p><strong>算法</strong></p>
<ol>
<li>比较相邻的元素，前一个比后一个大（或者前一个比后一个小）调换位置</li>
<li>每一对相邻的元素进行重复的工作，从开始对一直到结尾对，这步完成后，结尾为做大或最小的数</li>
<li>针对除了最后一个元素重复进行上面的步骤。</li>
<li>重复1-3步骤直到完成排序</li>
</ol>
<p>动图演示：<br><img src="https://i.loli.net/2020/03/23/GZTE1u4xNa5sO3U.gif" alt="演示1"></p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//冒泡排序 从小到大</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
     <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
          <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
               <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
               <span class="token punctuation">{</span>
                    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
               <span class="token punctuation">}</span> 
          <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
     <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>程序运行结果</strong><br><img src="https://i.loli.net/2020/03/23/kNrH89mGM3LPRXT.png" alt="冒泡排序"></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p>选择排序共需要的比较次数为n*(n-1) / 2，因此选择排序算法的时间复杂度与冒泡排序一样，也为O(n^2)</p>
</blockquote>
<p><strong>算法简介：</strong></p>
<ol>
<li><p>初始状态：序列为无序状态。</p>
</li>
<li><p>第1次排序：从n个元素中找出最小(大)元素与第1个记录交换</p>
</li>
<li><p>第2次排序：从n-1个元素中找出最小(大)元素与第2个记录交换</p>
</li>
<li><p>第i次排序：从n-i+1个元素中找出最小(大)元素与第i个记录交换</p>
</li>
<li><p>以此类推直到排序完成</p>
<p>动图演示<br><img src="https://i.loli.net/2020/03/23/GZTE1u4xNa5sO3U.gif" alt="演示2"></p>
</li>
</ol>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//选择排序 从大到小</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token comment" spellcheck="true">//函数申明</span>
<span class="token keyword">void</span> <span class="token function">choice</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">show</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">show</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">choice</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">show</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//选择排序</span>
<span class="token keyword">void</span> <span class="token function">choice</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token punctuation">,</span> j <span class="token punctuation">,</span>tmp<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
       <span class="token punctuation">{</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
           <span class="token punctuation">{</span>
             tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
             a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
             a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//显示</span>
<span class="token keyword">void</span> <span class="token function">show</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>运行结果<br><img src="https://i.loli.net/2020/03/23/FcuD1isKLjmSqVT.png" alt="运行结果"> </p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote>
<p>插入排序是一个比较直观的算法，对于n个元素，一共需要进行n-1轮比较，而第k轮比较需要进行k次数组元素的两两比较，因此共需要进行的比较次数为：1 + 2 + … + (n-1)，所以插入排序的时间复杂度同冒泡排序一样，也为O(n^2)</p>
</blockquote>
<p><strong>算法简介：</strong></p>
<ol>
<li>从第一个元素开始，该元素可认为已排序。</li>
<li>取出下一个元素，在排序好的元素序列中从后往前扫描</li>
<li>如果元素(已排序)大于新元素，将该元素移到下一位置</li>
<li>重复3.直到找到已排序的元素小于或等于新元素的位置</li>
<li>将新元素插入该位置后</li>
<li>重复2-5直到排序完成</li>
</ol>
<p><strong>动图演示</strong><br> <img src="https://i.loli.net/2020/03/23/xJ8Z5zAPDG1yawm.gif" alt="演示3"></p>
<p><strong>代码部分</strong></p>
<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//插入排序(从小到大) </span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>

<span class="token comment" spellcheck="true">//定义一个插入函数"insertion_sort" </span>
<span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>number<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>    
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>ii<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>temp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  
     <span class="token comment" spellcheck="true">//循环遍历 </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//将temp每一次赋值为number[i] </span>
        temp<span class="token operator">=</span>number<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        ii<span class="token operator">=</span>i<span class="token number">-1</span><span class="token punctuation">;</span>  
        <span class="token comment" spellcheck="true">//这里改顺序 (temp后的)"&lt;"为小到大，">"为大到小 ！！！</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>ii<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>temp<span class="token operator">&lt;</span>number<span class="token punctuation">[</span>ii<span class="token punctuation">]</span><span class="token punctuation">)</span>   
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//将大的元素往前放 </span>
            number<span class="token punctuation">[</span>ii<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>number<span class="token punctuation">[</span>ii<span class="token punctuation">]</span><span class="token punctuation">;</span>   
            ii<span class="token operator">--</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        number<span class="token punctuation">[</span>ii<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//与"number[ii+1]=number[ii];"一起意为 </span>
    <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">//如果插入的数比之前的大,将number[ii]与number[ii+1]互换 </span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
   <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">insertion_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>运行结果<br><img src="https://i.loli.net/2020/03/23/Je2jSTp85luKMZt.png" alt="运行结果"></p>
<hr>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法类</tag>
        <tag>语言类</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机开发板引脚图</title>
    <url>/2020/02/12/5.%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BC%95%E8%84%9A%E5%9B%BE/</url>
    <content><![CDATA[<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<h2 id="Arduino-开发板引脚图"><a href="#Arduino-开发板引脚图" class="headerlink" title="Arduino 开发板引脚图"></a>Arduino 开发板引脚图</h2><p><img src="https://i.loli.net/2020/03/23/RtHcZmr7dW5ljJ1.png" alt="1"><br><img src="https://i.loli.net/2020/03/23/YTt1iCPKv9AxVLr.png" alt="2"></p>
<p><img src="https://i.loli.net/2020/03/23/XnrG3CcTbEVhYPJ.png" alt="3"><br><img src="https://i.loli.net/2020/03/23/qjebOdw6RU9vaiL.png" alt="4"></p>
<h2 id="esp8266-引脚图"><a href="#esp8266-引脚图" class="headerlink" title="esp8266 引脚图"></a>esp8266 引脚图</h2><p><img src="https://i.loli.net/2020/03/23/HwY2Ao1W9UfmcQJ.png" alt="5"></p>
<p><img src="https://i.loli.net/2020/03/23/uqnUV62XZw13ghG.png" alt="6"></p>
<h2 id="STC89C51单片机引脚图"><a href="#STC89C51单片机引脚图" class="headerlink" title="STC89C51单片机引脚图"></a>STC89C51单片机引脚图</h2><p><img src="https://i.loli.net/2020/03/23/PQxlYmaVji6D4rF.png" alt="7"></p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>语言类</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言之字节序</title>
    <url>/2020/02/10/4.C%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%AD%97%E8%8A%82%E5%BA%8F/</url>
    <content><![CDATA[<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<h2 id="字节序理解"><a href="#字节序理解" class="headerlink" title="字节序理解"></a>字节序理解</h2><p>字节序其实就是数据在内存中的存储方式，因为内存的地址用高低位之分，数据也有高低位，所以按照存放的顺序一般可分为大端字节序，和小段字节序。</p>
<p>生活中我们放东西的顺序也是不一样的，有的人习惯性的将自己的物品放在自己的左手边，有的人就习惯性的放在自己的右手边，那对于电脑来说，cpu的不同，内存存储多字节数据的存储方式也相应的不同。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="主机字节序"><a href="#主机字节序" class="headerlink" title="主机字节序"></a>主机字节序</h2><p>不同类型CPU主机中，内存存储多字节整数的方法不同，称为主机字节序</p>
<p><strong>主机序列有两种</strong><br>小端序 ：数据的低字节存放在内存的低地址<br>大端序 ：数据的高字节存放在内存的低地址 </p>
<blockquote>
<p>一般 inter处理器的字节序为 小端序， 而 ARM 架构的处理器多为大端序</p>
</blockquote>
<h2 id="验证主机字节序"><a href="#验证主机字节序" class="headerlink" title="验证主机字节序"></a>验证主机字节序</h2><p>C语言<code>代码片</code></p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment" spellcheck="true">//定义一个共用体</span>
<span class="token keyword">union</span> Data
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">char</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">union</span> Data data<span class="token punctuation">;</span>
    data<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">0x12345678</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//小端序</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0x78</span> <span class="token operator">==</span> data<span class="token punctuation">.</span>b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the little end sequence\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//大端序</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the big end sequence\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="编程结果"><a href="#编程结果" class="headerlink" title="编程结果"></a>编程结果</h2><p><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/4/1.png" alt="inter处理器"></p>
<p><strong>运行代码的电脑是inter处理器的，验证为小端序存储</strong></p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>语言类</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言之字符串处理</title>
    <url>/2020/02/09/3.c%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<h1 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul>
<li>在c语言的学习过程中，我们会学习很多字符串处理函数，入strlen，strcpy，strcmp等等,使用也特别简单，只需要调用库函数就行。</li>
<li>但是对于c语言初学者来说，作为一个面向过程的语言，了解其函数内的实现过程还非常用必要的。</li>
</ul>
<h2 id="2-字符串实现函数"><a href="#2-字符串实现函数" class="headerlink" title="2.字符串实现函数"></a>2.字符串实现函数</h2><h3 id="strcpy（字符串拷贝函数）"><a href="#strcpy（字符串拷贝函数）" class="headerlink" title="strcpy（字符串拷贝函数）"></a>strcpy（字符串拷贝函数）</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> M 50</span>
<span class="token comment" spellcheck="true">//指针函数 返回值为指向字符串str1的指针</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> str1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> str2 <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//判断 是否为空指针</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> str2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> str1<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span> str1<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span> str2<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> str2<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input str1\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fgets</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">strcpy</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>运行结果</strong><br><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/3/1.png" alt="运行1"></p>
<blockquote>
<p>注意：fgets输入的时候会将缓存区里面的回车换行</p>
</blockquote>
<p><strong>作为笔试题考察点有四处</strong></p>
<ol>
<li>异常处理  str1，str2 是否为NULL</li>
<li>const 的修饰，str2不能被修改需要const来修饰</li>
<li>字符串会拷贝 ‘\0’ </li>
<li>返回值（指向str2的指针），可以方便调用者调用</li>
</ol>
<h3 id="strcmp（字符串比较大小）"><a href="#strcmp（字符串比较大小）" class="headerlink" title="strcmp（字符串比较大小）"></a>strcmp（字符串比较大小）</h3><pre class=" language-c"><code class="language-c"><span class="token operator">*</span><span class="token operator">*</span>#include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span>
<span class="token macro property">#<span class="token directive keyword">define</span> M 50</span>
<span class="token macro property">#<span class="token directive keyword">define</span> N 50</span>
<span class="token keyword">int</span> <span class="token function">Strcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//输入两个字符串</span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> str2<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input str1\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input str2\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//比较两字符串的大小</span>
    <span class="token function">Strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">Strcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//判断 是否为空指针</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> str2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
          <span class="token keyword">return</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>str1<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">*</span><span class="token punctuation">(</span>str2<span class="token operator">+</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token punctuation">(</span>str1<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span><span class="token punctuation">(</span>str1<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">*</span><span class="token punctuation">(</span>str2<span class="token operator">+</span>i<span class="token punctuation">)</span> <span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str1>str2\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">*</span><span class="token punctuation">(</span>str1<span class="token operator">+</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>str2<span class="token operator">+</span>i<span class="token punctuation">)</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str1&lt;str2\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"str1=str2\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>运行结果</strong><br><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/3/2.png" alt="运行2"><br><strong>作为笔试题考点同上</strong></p>
<h3 id="strcat-（字符串拼接函数）"><a href="#strcat-（字符串拼接函数）" class="headerlink" title="strcat （字符串拼接函数）"></a>strcat （字符串拼接函数）</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> M 50</span>
<span class="token macro property">#<span class="token directive keyword">define</span> N 50</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">str_cat</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> str2<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//输入两个字符串</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input str1\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input str2\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token function">str_cat</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">puts</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//字符串拼接</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">str_cat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>str2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//判断 是否为空指针</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> str2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">//字符串str1的长度</span>
     <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//字符串str2的长度</span>
     <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> M <span class="token operator">&lt;</span> <span class="token punctuation">(</span>j<span class="token operator">+</span>k<span class="token punctuation">)</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//定义两个指针</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>pp<span class="token operator">=</span>str1<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span>str1<span class="token operator">+</span>j<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>q<span class="token operator">=</span>str2<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> pp<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>运行结果</strong><br><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/3/4.png" alt="运行3"></p>
<h3 id="strlen（求字符串的长度）"><a href="#strlen（求字符串的长度）" class="headerlink" title="strlen（求字符串的长度）"></a>strlen（求字符串的长度）</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"please input str\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//用变量a来接受函数的返回值</span>
    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token function">mystrlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\r\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//求字符串的长度</span>
<span class="token keyword">int</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pStr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>pStr<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>pStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span><span class="token string">'\0'</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/3/4.png" alt="运行4"></p>
<blockquote>
<p>注意：strlen 和 sizeof的区别</p>
</blockquote>
<ul>
<li>strlen 计算字符串的长度，不计算字符串的结束标识符 ‘\0’</li>
<li>sizeof 计算的是占空间的大小会计算进去</li>
</ul>
<h3 id="字符串的翻转"><a href="#字符串的翻转" class="headerlink" title="字符串的翻转"></a>字符串的翻转</h3><p>*<em>方法一 *</em></p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> n 50</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//输入字符</span>
    <span class="token keyword">char</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span>arr<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>q<span class="token operator">=</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//用指针p指向首地址，q指向字符的尾地址</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">strlen</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>    
        <span class="token keyword">char</span> tmp<span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">puts</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/3/5.png" alt="运行5"><br><strong>方法二</strong></p>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span>str<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>q<span class="token operator">=</span>str<span class="token operator">+</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&lt;</span>q<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tmp<span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span>
        <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">*</span>q<span class="token punctuation">;</span>
        <span class="token operator">*</span>q<span class="token operator">=</span>tmp<span class="token punctuation">;</span>
        p<span class="token operator">++</span><span class="token punctuation">;</span>
        q<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">puts</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="字符串的查找"><a href="#字符串的查找" class="headerlink" title="字符串的查找"></a>字符串的查找</h3><blockquote>
<p>编写一个字符串查找函数，函数原型为：<br>char *str_search(const char *str1, const char *str2)，<br>该函数实现在字符串str1中找出字符串str2第一次出现的位置。<br>如果str2出现在str1中，则返回str2在str1中出现的首地址，<br>如果在str1中没有与str2匹配的字符串则返回NULL</p>
</blockquote>
<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">str_search</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>str2 <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//定义两个字符串</span>
    <span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//赋值</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token function">str_search</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\r\n"</span><span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">str_search</span><span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>str2 <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//定义一个指针指向 str1</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> str1<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//逐个移动比较</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">char</span> tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span> p<span class="token operator">+</span><span class="token function">strlen</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token operator">+</span>i <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">*</span><span class="token punctuation">(</span> p<span class="token operator">+</span><span class="token function">strlen</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token operator">+</span>i <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//比较两个字符串</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token operator">==</span> <span class="token function">strcmp</span><span class="token punctuation">(</span> str1<span class="token operator">+</span>i<span class="token punctuation">,</span> str2 <span class="token punctuation">)</span> <span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> p<span class="token operator">+</span>i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>    
        <span class="token operator">*</span><span class="token punctuation">(</span> p<span class="token operator">+</span><span class="token function">strlen</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token operator">+</span>i <span class="token punctuation">)</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>    </code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/3/6.png" alt="运行6"></p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>语言类</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识点总结</title>
    <url>/2020/02/02/11.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>《计算机网络》第五版 谢希仁</strong> 知识点大汇总</p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<h2 id="1-OSI、TCP-IP、五层协议的体系结构以及各层协议"><a href="#1-OSI、TCP-IP、五层协议的体系结构以及各层协议" class="headerlink" title="1.OSI、TCP/IP、五层协议的体系结构以及各层协议"></a>1.OSI、TCP/IP、五层协议的体系结构以及各层协议</h2><p><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/11/1.png" alt="1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/11/2.png" alt="2"></p>
<p><strong>OSI分层（7层）</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>TCP/IP分层（4层）</strong>：网络接口层、网际层、运输层、应用层。</p>
<p><strong>五层协议（5层）</strong>：物理层、数据链路层、网络层、运输层、应用层。</p>
<p><strong><em>每一层的协议如下：</em></strong></p>
<p><strong>物理层：</strong><code>RJ45</code>、<code>CLOCK</code>、<code>IEEE802.3</code>   （中继器，集线器，网关）</p>
<p><strong>数据链路：</strong><code>PPP</code>、<code>FR</code>、<code>HDLC</code>、<code>VLAN</code>、<code>MAC</code>  （网桥，交换机）</p>
<p><strong>网络层：</strong><code>IP</code>、<code>ICMP</code>、<code>ARP</code>、<code>RARP</code>、<code>OSPF</code>、<code>IPX</code>、<code>RIP</code>、<code>IGRP</code> （路由器）</p>
<p><strong>传输层：</strong><code>TCP</code>、<code>UDP</code>、<code>SPX</code></p>
<p><strong>会话层：</strong><code>NFS</code>、<code>SQL</code>、<code>NETBIOS</code>、<code>RPC</code></p>
<p><strong>表示层：</strong><code>JPEG</code>、<code>MPEG</code>、<code>ASII</code></p>
<p><strong>应用层：</strong><code>FTP</code>、<code>DNS</code>、<code>Telnet</code>、<code>SMTP</code>、<code>HTTP</code>、<code>WWW</code>、<code>NFS</code></p>
<p><strong><em>每一层的作用如下：</em></strong></p>
<p><strong>物理层：</strong>通过媒介传输比特,确定机械及电气规范（比特 <code>Bit</code>）</p>
<p><strong>数据链路层</strong>：将比特组装成帧和点到点的传递（帧 <code>Frame</code>）</p>
<p><strong>网络层</strong>：负责数据包从源到宿的传递和网际互连（包 <code>PackeT</code>）</p>
<p><strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复（段 <code>Segment</code>）</p>
<p><strong>会话层</strong>：建立、管理和终止会话（会话协议数据单元 <code>SPDU</code>）</p>
<p><strong>表示层</strong>：对数据进行翻译、加密和压缩（表示协议数据单元 <code>PPDU</code>）</p>
<p><strong>应用层</strong>：允许访问 <code>OSI</code> 环境的手段（应用协议数据单元 <code>APDU</code>）</p>
<h2 id="2-IP地址分类"><a href="#2-IP地址分类" class="headerlink" title="2.IP地址分类"></a>2.IP地址分类</h2><p>　　<code>IP</code> 地址是32位的二进制数值，用于在 <code>TCP/IP</code> 通讯协议中标记每台计算机的地址。通常我们使用点式十进制来表示，如192.168.0.5等等。</p>
<p>　　每个 <code>IP</code> 地址又可分为两部分。即网络号部分和主机号部分：网络号表示其所属的网络段编号，主机号则表示该网段中该主机的地址编号。按照网络规模的大小，<code>IP</code> 地址可以分为 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code> 五类。</p>
<p>A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；</p>
<p>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</p>
<p>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</p>
<pre><code>类别         网络号                  /占位数      主机号             /    占位数    用途

A（以0开头）  1～126                 /  8      0～255 0～255 1～254 /     24      国家级

B（以10开头） 128～191 0～255        /  16     0～255 1～254        /     16      跨过组织

C（以110开头）192～223 0～255 0～255 /  24     1～254               /     8       企业组织</code></pre><p><strong>注意：</strong></p>
<p>1）以下是留用的内部私有地址，<code>Internet</code> 上没使用的地址</p>
<p><code>A</code> 类 10.0.0.0–10.255.255.255</p>
<p><code>B</code> 类 172.16.0.0–172.31.255.255</p>
<p><code>C</code> 类 192.168.0.0–192.168.255.255</p>
<p>2）<code>IP</code> 地址与子网掩码相与得到网络号</p>
<p>3）主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255）</p>
<h2 id="3-ARP是地址解析协议，简单语言解释一下工作原理"><a href="#3-ARP是地址解析协议，简单语言解释一下工作原理" class="headerlink" title="3.ARP是地址解析协议，简单语言解释一下工作原理"></a>3.ARP是地址解析协议，简单语言解释一下工作原理</h2><p>地址解析协议，即 <code>ARP</code>（<code>Address Resolution Protocol</code>），是根据 <code>IP</code> 地址获取物理地址的一个 <code>TCP/IP</code> 协议。</p>
<p>1.首先，每个主机都会在自己的 <code>ARP</code> 缓冲区中建立一个 <code>ARP</code> 列表，以表示 <code>IP</code> 地址和 <code>MAC</code> 地址之间的对应关系。</p>
<p>2.当源主机要发送数据时，首先检查ARP列表中是否有对应 <code>IP</code> 地址的目的主机的 <code>MAC</code> 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 <code>ARP</code> 数据包，该数据包包括的内容有：源主机<code>IP</code>地址，源主机 <code>MAC</code> 地址，目的主机的 <code>IP</code> 地址</p>
<p>3.当本网络的所有主机收到该 <code>ARP</code> 数据包时，首先检查数据包中的 <code>IP</code> 地址是否是自己的 <code>IP</code> 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 <code>IP</code> 和 <code>MAC</code> 地址写入到 <code>ARP</code> 列表中，如果已经存在，则覆盖，然后将自己的 <code>MAC</code> 地址写入 <code>ARP</code> 响应包中，告诉源主机自己是它想要找的 <code>MAC</code> 地址。</p>
<p>4.源主机收到 <code>ARP</code> 响应包后。将目的主机的 <code>IP</code> 和 <code>MAC</code> 地址写入 <code>ARP</code> 列表，并利用此信息发送数据。如果源主机一直没有收到 <code>ARP</code> 响应数据包，表示 <code>ARP</code> 查询失败。</p>
<p><strong>注意：广播（255.255.255.255）发送 <code>ARP</code> 请求，单播发送 <code>ARP</code> 响应。</strong></p>
<h2 id="4-简单介绍几种协议"><a href="#4-简单介绍几种协议" class="headerlink" title="4.简单介绍几种协议"></a>4.简单介绍几种协议</h2><p><code>ICMP</code> 协议： 因特网控制报文协议。它是 <code>TCP/IP</code> 协议族的一个子协议，用于在 <code>IP</code> 主机、路由器之间传递控制消息</p>
<p><code>TFTP</code> 协议： 是 <code>TCP/IP</code> 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<p><code>HTTP</code> 协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统</p>
<p><code>NAT</code> 协议：网络地址转换属接入广域网( <code>WAN</code> )技术，是一种将私有（保留）地址转化为合法 <code>IP</code> 地址的转换技术</p>
<p><code>DHCP</code> 协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用 <code>UDP</code> 协议工作。<strong>具体用途</strong>：给内部网络或网络服务供应商自动分配 <code>IP</code> 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h2 id="5-TCP三次握手四次挥手"><a href="#5-TCP三次握手四次挥手" class="headerlink" title="5.TCP三次握手四次挥手"></a>5.TCP三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：客户端发送 <code>syn</code> 包( <code>seq=x</code> )到服务器，并进入 <code>SYN_SEND</code> (发送)状态，等待服务器确认；</p>
<p>第二次握手：服务器收到 <code>syn</code>包，必须确认客户的 <code>SYN</code>（<code>ack=x+1</code>），同时自己也发送一个 <code>SYN</code> 包（<code>seq=y</code> ），即 <code>SYN+ACK</code> 包，此时服务器进入 <code>SYN_RECV</code>（接收）状态；</p>
<p>第三次握手：客户端收到服务器的 <code>SYN＋ACK</code> 包，向服务器发送确认包 <code>ACK</code> ( <code>ack=y+1</code> )，此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（已建立）状态，完成三次握手。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/11/3.png" alt="3"></p>
<p><strong>说明：</strong><br>1）<code>SYN</code> 和 <code>ACK</code> 是标志位（0/1）（<code>ACK=1</code>表明 <code>ack</code> 有效），<code>seq</code> 是序列号，<code>ack</code> 是确认号。</p>
<p>2）给对方的确认方式就是把对方传来的 <code>seq+1</code> 并赋给 <code>ack</code>。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一次挥手：主动关闭方发送一个 <code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在 <code>fin</code> 包之前发送出去的数据，如果没有收到对应的 <code>ack</code> 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
<p>第二次挥手：被动关闭方收到 <code>FIN</code> 包后，发送一个 <code>ACK</code> 给对方，确认序号为收到序号 +1。</p>
<p>第三次挥手：被动关闭方发送一个 <code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手：主动关闭方收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 给被动关闭方，确认序号为收到序号 +1，至此，完成四次挥手。</p>
<p><strong>说明：</strong></p>
<p>1）<strong>SYN攻击：用众多伪造ip地址向服务器发送SYN=1（请求连接）</strong>，让服务器处于<strong>SYN-RCVD状态</strong>，但都无法第三次握手（因为伪造 <code>ip</code> 不存在）</p>
<p>2）4次挥手中的 <code>FIN</code> 就相当于三次握手中的 <code>SYN</code>。</p>
<p>3）序号 <code>seq</code>，确认序号 <code>ack</code>，确认标志位 <code>ACK</code> 作用还是一样的，就是确认作用（把 <code>seq</code> 加上1赋给 <code>ack</code>，并把 <code>ACK</code> 置1）</p>
<p>4）为什么一个3次1个4次不一样？</p>
<p>因为两端的数据并不是同时发送完，所以两端谁发送完数据都需要自己告诉对方一次，并且对方确认一次。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bigoceans/cdn/img/post/11/4.png" alt="4"></p>
<h2 id="6-在浏览器中输入www-baidu-com-后执行的全部过程"><a href="#6-在浏览器中输入www-baidu-com-后执行的全部过程" class="headerlink" title="6.在浏览器中输入www.baidu.com 后执行的全部过程"></a>6.在浏览器中输入<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 后执行的全部过程</h2><p>1、客户端浏览器通过 <code>DNS</code> 解析到<a href="http://www.baidu.com的" target="_blank" rel="noopener">www.baidu.com的</a> <code>IP</code> 地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个 <code>HTTP</code> 会话到 220.161.27.48，然后通过 <code>TCP</code> 进行封装数据包，输入到网络层。</p>
<p> 2、在客户端的<strong>传输层(添加TCP头)</strong>，把 <code>HTTP</code> 会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的 5000 端口。然后使用IP层的IP地址查找目的端。</p>
<p> 3、客户端的<strong>网络层（添加IP头）</strong>不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p> 4、客户端的<strong>链路层（添加MAC头）</strong>包通过链路层发送到路由器，通过邻居协议查找给定 <code>IP</code> 地址的 <code>MAC</code> 地址，然后发送 <code>ARP</code> 请求查找目的地址，如果得到回应后就可以使用 <code>ARP</code> 的请求应答交换的 <code>IP</code> 数据包现在就可以传输了，然后发送 <code>IP</code> 数据包到达服务器的地址。</p>
<h2 id="7-TCP和UDP的区别"><a href="#7-TCP和UDP的区别" class="headerlink" title="7.TCP和UDP的区别"></a>7.TCP和UDP的区别</h2><p><strong>这是传输层的两个协议，先说一下传输层的两大功能：</strong></p>
<ol>
<li><strong>复用：</strong>在发送端，多个应用进程公用一个传输层；</li>
<li><strong>分用：</strong>在接收端，传输层会根据端口号将数据分给不同的应用进程。 </li>
</ol>
<p><strong>传输层和网络层的区别：</strong></p>
<ol>
<li>网络层为不同的<strong>主机</strong>提供通信服务，传输层为不同应用<strong>进程</strong>提供通信服务。</li>
<li>网络层只对报文头部进行差错检测，而传输层对整个报文进行差错检测。</li>
</ol>
<p><strong>UDP（User Data Protocol）用户数据报协议</strong></p>
<ol>
<li>无连接</li>
<li>不可靠（不能保证都送达）</li>
<li>面向报文（<code>UDP</code> 数据传输单位是报文，不会对数据进行拆分和拼接操作，只是给上层传来的数据加个 <code>UDP</code> 头或者给下层来的数据去掉 <code>UDP</code> 头）</li>
<li>没有拥塞控制，始终以恒定速率发送数据</li>
<li>支持一对一、一对多、多对多、多对一</li>
<li>首部开销小，只有8字节</li>
</ol>
<p><strong>TCP（Transmission Control Protocol）传输控制协议</strong></p>
<ol>
<li>有连接</li>
<li>可靠的</li>
<li>面向字节流</li>
<li>全双工通信，<code>TCP</code> 两端既可以作为发送端也可以作为接收端</li>
<li>连接的两端只能是两个端点，即一对一，不能一对多</li>
<li>至少20个字节，比 <code>UDP</code> 大的多</li>
</ol>
<p><strong>什么是TCP连接</strong></p>
<p><code>TCP</code> 连接是一种抽象的概念，表示一条可以通信的链路。<br>每个 <code>TCP</code> 连接有且仅有两个端点，表示通信的双方，且双方在任意时刻都可以作为发送者和接受者。</p>
<p><strong>什么是套接字</strong></p>
<p>一条 <code>TCP</code> 连接的两端就是两个套接字。<br>套接字 = <code>IP</code> 地址:端口号<br>因此，<code>TCP</code> 连接 = （套接字1，套接字2）= （<code>IP1</code>：端口号1，<code>IP2</code>：端口号2）</p>
<h2 id="8-TCP对应的协议和UDP对应的协议"><a href="#8-TCP对应的协议和UDP对应的协议" class="headerlink" title="8.TCP对应的协议和UDP对应的协议"></a>8.TCP对应的协议和UDP对应的协议</h2><p><strong>TCP对应的协议：</strong></p>
<p>（1） <strong>FTP</strong>：定义了文件传输协议，使用<strong>21</strong>端口。</p>
<p>（2） <strong>Telnet</strong>：一种用于远程登陆的端口，使用<strong>23</strong>端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。</p>
<p>（3） <strong>SMTP</strong>：邮件传送协议，用于发送邮件。服务器开放的是<strong>25</strong>号端口。</p>
<p>（4） <strong>POP3</strong>：它是和 <code>SMTP</code> 对应，<code>POP3</code> 用于接收邮件。<code>POP3</code> 协议所用的是<strong>110</strong>端口。</p>
<p>（5）<strong>HTTP</strong>：是从 <code>Web</code> 服务器传输超文本到本地浏览器的传送协议。</p>
<p><strong>UDP对应的协议：</strong></p>
<p>（1） <strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是<strong>53</strong>号端口。</p>
<p>（2） <strong>SNMP</strong>：简单网络管理协议，使用<strong>161</strong>号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>（3） <strong>TFTP</strong>(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口<strong>69</strong>上使用UDP服务。</p>
<h2 id="9-DNS域名系统，简单描述其工作原理。"><a href="#9-DNS域名系统，简单描述其工作原理。" class="headerlink" title="9.DNS域名系统，简单描述其工作原理。"></a>9.DNS域名系统，简单描述其工作原理。</h2><p>　　当 <code>DNS</code> 客户机需要在程序中使用名称时，它会查询 <code>DNS</code> 服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的 <code>DNS</code> 域名，指定的查询类型，<code>DNS</code> 域名的指定类别。基于 <code>UDP</code> 服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如 <code>HTTP</code>，<code>SMTP</code>等在其中需要完成主机名到IP地址的转换。</p>
<h2 id="10-面向连接和非面向连接的服务的特点是什么？"><a href="#10-面向连接和非面向连接的服务的特点是什么？" class="headerlink" title="10.面向连接和非面向连接的服务的特点是什么？"></a>10.面向连接和非面向连接的服务的特点是什么？</h2><ul>
<li><p>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。</p>
</li>
<li><p>非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</p>
</li>
</ul>
<h2 id="11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#11-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>11.TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h2><p>答：建立连接的过程是利用客户服务器模式，假设主机 <code>A</code> 为客户端，主机 <code>B</code> 为服务器端。</p>
<p>（1）<code>TCP</code> 的三次握手过程：主机 <code>A</code> 向 <code>B</code> 发送连接请求；主机 <code>B</code> 对收到的主机 <code>A</code> 的报文段进行确认；主机 <code>A</code> 再次对主机 <code>B</code> 的确认进行确认。</p>
<p>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 <code>B</code>，因而产生错误。失效的连接请求报文段是指：<strong>主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。</strong>考虑这样一种特殊情况，主机 <code>A</code> 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 <code>B</code>，<strong>主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会</strong>，主机 <code>B</code> 就一直在等待主机 <code>A</code> 发送数据，导致主机 <code>B</code> 的资源浪费。（这就是缺少第三次握手( <code>A</code> 再给 <code>B</code> 确认））</p>
<p>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</p>
<h2 id="12-了解交换机、路由器、网关的概念，并知道各自的用途"><a href="#12-了解交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="12.了解交换机、路由器、网关的概念，并知道各自的用途"></a>12.了解交换机、路由器、网关的概念，并知道各自的用途</h2><p><strong>1）交换机</strong></p>
<p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，<strong>处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上</strong>，通过内部 交换矩阵迅速将数据包传送到目的端口。目的 <code>MAC</code> 若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。</p>
<p><strong>交换机工作于OSI参考模型的第二层，即数据链路层</strong>。交换机内部的 <code>CPU</code> 会在每个端口成功连接时，通过 <code>ARP</code> 协议学习它的 <code>MAC</code> 地址，保存成一张 <code>ARP</code>表。在今后的通讯中，发往该 <code>MAC</code> 地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。</p>
<p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p>
<p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在 <code>OSI</code> 七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p>
<p><strong>2）路由器</strong></p>
<p><strong>路由器</strong>（<strong>Router</strong>）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（ <code>host</code> 到 <code>host</code> 之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转送。路由工作在<strong>OSI模型的第三层——即网络层</strong>，例如网际协议。</p>
<p><strong>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</strong> 路由器与交换器的差别，路由器是属于 <code>OSI</code> 第三层的产品，交换器是 <code>OSI</code> 第二层的产品(这里特指二层交换机)。</p>
<p><strong>3）网关</strong></p>
<p><strong>网关</strong>（<code>Gateway</code>），<strong>网关</strong>顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关<code>TCP/IP</code> 的文献曾经把网络层使用的路由器（<code>Router</code>）称为网关，<strong>在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP</strong>），经常在家庭中或者小型企业网络中使用，用于连接局域网和 <code>Internet</code>。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p>
<blockquote>
<p>文章来源于网络</p>
<p>原文链接：<a href="https://www.cnblogs.com/xdyixia/p/9275246.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdyixia/p/9275246.html</a></p>
</blockquote>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>网络类</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/01/27/10.%E5%9B%BE/</url>
    <content><![CDATA[<p>此图非彼图，今天来学习一种十分重要，在生活中也经常使用的数据结构「图」</p>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
<h2 id="一、图"><a href="#一、图" class="headerlink" title="一、图"></a>一、图</h2><p>图就是由一些点与边组成，点之间是边，边两头有点，类似于我们所画的思维导图。根据点之间连接的边是否有具体指向区分为『有向图』和『无向图』。</p>
<p>那么，<br>图可以做什么呢？它可以解决最经典的问题『寻找最短路径』。类似于地图，如想知道从别墅到公司走哪条路最短，可以通过图来建立模型，将十字路口（三叉路口等连接几条路的路口）看作是点，每条路就是边，别墅是起点，公司是终点。</p>
<p>上面只完成了第一步，有了图之后，该如何寻找最短路径呢？下面就需要再介绍一种图算法『广度优先搜索』</p>
<h2 id="二、广度优先搜索算法"><a href="#二、广度优先搜索算法" class="headerlink" title="二、广度优先搜索算法"></a>二、广度优先搜索算法</h2><p><strong>广度优先搜索算法</strong>可以通过一个例子进行描述：小明想通过走动，帮助儿子进入县一中（当地最好的学校）。于是他开始回忆自己的朋友是否有县一中的领导或者认识其领导，思考之后发现并没有，然后让朋友询问朋友的朋友是否有关系。像这样，为了在社交网络中寻找到关系，先看自己（自己肯定不是，要不然直接安排了），然后将所有朋友加入到搜索名单中，看朋友中是否有关系，如果没有，再将朋友的朋友纳入范围继续寻找 …… 直到找到需要的人，这就是广度优先搜索算法。</p>
<blockquote>
<p>因为同朋友的亲密度比同朋友的朋友之间的亲密度要高，所以先从朋友之间寻找。如果将朋友比做是第一层关系，朋友的朋友为第二层，这样一层一层下去的就是广度优先搜索。如果找到一个朋友，就寻找他的朋友中是否有这样的人，如此以深度挖掘的方式搜索下去，就是深度优先搜索。</p>
</blockquote>
<p>它常用于寻找两地点或者两样物体之间的最短距离。总结为下面两种问题：</p>
<ul>
<li>从一点可以到另一点吗？</li>
<li>从一点到另一点哪条路径最短？</li>
</ul>
<p>现实生活中的例子有：</p>
<ul>
<li>各种智能机器，比如跳棋最少走几步可以获胜</li>
<li>到目的地的最短路线</li>
</ul>
<p>在搜索的过程中，大家可能注意到，先检查朋友，后检查朋友的朋友，是有顺序的，那么如何保持顺序呢？那就需要使用到另外一种数据结构『队列』</p>
<h2 id="三、队列"><a href="#三、队列" class="headerlink" title="三、队列"></a>三、队列</h2><p>队列很简单，和生活中的排队一样，比如购票，结账时，先排队的人先买到票或者结账完成。就是有顺序，先进先出（<code>First In First Out</code>）的一种数据结构，它只有两种行为，入队和出队。类比生活中排队，有素质的人不能出现插队吧？</p>
<blockquote>
<p>队列常常与栈进行对比，栈是一种先进后出的数据结构，或描述为后进先出（<code>Last In First Out</code>）</p>
<p>深度优先搜索就常使用栈。</p>
</blockquote>
<h2 id="四、实现图"><a href="#四、实现图" class="headerlink" title="四、实现图"></a>四、实现图</h2><p>代码如何实现图呢？首先图由多个节点构成，每个节点与邻近节点相连，要表示这种关系，可以联想到『散列表』，其映射关系可以将键映射到一个值或多个值。在 <code>Python</code> 中则使用字典表示：</p>
<pre class=" language-python"><code class="language-python">graph <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
graph<span class="token punctuation">[</span><span class="token string">"小明"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"小花"</span><span class="token punctuation">,</span> <span class="token string">"小玉"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
graph<span class="token punctuation">[</span><span class="token string">"小玉"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"小帆"</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></code></pre>
<blockquote>
<p>散列表是无序的</p>
</blockquote>
<h2 id="五、实现图算法"><a href="#五、实现图算法" class="headerlink" title="五、实现图算法"></a>五、实现图算法</h2><p>还是沿用小明为儿子学校找关系的示例，实现代码如下：</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 该字典表示图，其中将小明与朋友，小明朋友与朋友的朋友之间的关系</span>
graph <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>

<span class="token keyword">def</span> <span class="token function">person_is_seller</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 具体判断过程省略，该函数返回 true 或 false，即是或者不是</span>
    <span class="token keyword">pass</span>

<span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 创建一个队列</span>
    search_queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token comment" spellcheck="true"># 为队列中不断添加朋友或者朋友的朋友，即要搜索的人</span>
    search_queue <span class="token operator">+=</span> graph<span class="token punctuation">[</span>name<span class="token punctuation">]</span> 
    <span class="token comment" spellcheck="true"># 这个列表用于记录检查过的人</span>
    searched <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true"># 只要队列不为空就一直搜索下去</span>
    <span class="token keyword">while</span> search_queue<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 取出队列中左面第一个人</span>
        person <span class="token operator">=</span> search_queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span> 
        <span class="token comment" spellcheck="true"># 仅当这个人没检查过时才检查</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> person <span class="token keyword">in</span> searched<span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># 看这个人是否是小明需要找的关系</span>
            <span class="token keyword">if</span> person_is_seller<span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">:</span>
                  <span class="token comment" spellcheck="true"># 是的话输出是要找的关系</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span>person <span class="token operator">+</span> <span class="token string">" is the one you are looking for!"</span><span class="token punctuation">)</span>
                <span class="token comment" spellcheck="true"># 结束循环</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                  <span class="token comment" spellcheck="true"># 把这个人的朋友添加到队列中</span>
                  search_queue <span class="token operator">+=</span> graph<span class="token punctuation">[</span>person<span class="token punctuation">]</span> 
                <span class="token comment" spellcheck="true"># 将这个人标记为检查过</span>
                searched<span class="token punctuation">.</span>append<span class="token punctuation">(</span>person<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

search<span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span></code></pre>
<p><strong><em>更多精彩文章请关注公众号『大海的BLOG』</em></strong></p>
]]></content>
      <tags>
        <tag>算法类</tag>
      </tags>
  </entry>
</search>
